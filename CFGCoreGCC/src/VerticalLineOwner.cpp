/*
 * Copyright 2014-2022 joerg All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "VerticalLineOwner.h"

#include "CFGNode.h"

#include "CFGEdge.h"

#include "CFGLayer.h"

#include "settings.h"

#include <algorithm>

#include <stdio.h>

std::vector<VerticalLine *> *VerticalLineOwner::getVericalLinesForResort()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20--4061d8fd:15076c26818:-8000:0000000000000BFA begin
{
    return &ownedVerticalLines;
}
// section -64--88--78-20--4061d8fd:15076c26818:-8000:0000000000000BFA end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element


VerticalLineOwner::~VerticalLineOwner()
{

}

void VerticalLineOwner::startResort()
{
    tempResort.resize(ownedVerticalLines.size());
    for(unsigned int i = 0; i < ownedVerticalLines.size();++i)
    {
        tempResort[i] = ownedVerticalLines[i]->smoothOffset;
    }
}

void VerticalLineOwner::endResort()
{
    for(unsigned int i = 0; i < ownedVerticalLines.size();++i)
    {
        ownedVerticalLines[i]->smoothOffset = tempResort[i];
    }
}
int VerticalLineOwner::getSeekFreeSpacePositive(VerticalLine& line)
{
    int ret = 0;
    for(unsigned int i = 0; i < ownedVerticalLines.size();++i)
    {
        ret += ownedVerticalLines[i]->smoothOffset;
        if(ownedVerticalLines[i] == &line)
            return -ret;
    }
    //this should never happen
    return -ret;
}
int VerticalLineOwner::getSeekFreeSpaceNegative(VerticalLine& line)
{
    int ret = 0;
    for(unsigned int i = 0; i < ownedVerticalLines.size();++i)
    {
        ret += ownedVerticalLines[i]->smoothOffset;
        if(ownedVerticalLines[i] == &line)
            return -ret;
    }
    //this should never happen
    return -ret;
}

void VerticalLineOwner::internResort()
{
    //bubble sort because it needs to end at some point todo more effective sorting todo only sort each Linebinder once
    for(unsigned int i = 0;i != ownedVerticalLines.size();++i)
    {
    	bool donesomething = false;
        for(unsigned int j = 0;j != ownedVerticalLines.size() - 1;++j)
        {
            int pull = ownedVerticalLines[j]->getUsedLineBinder()->getPull();
            int negspace;
            if(pull < 0)
                negspace = ownedVerticalLines[j]->getUsedLineBinder()->getSeekFreeSpaceNegative();
            else
                negspace = ownedVerticalLines[j]->getUsedLineBinder()->getSeekFreeSpacePositive();

            int next = j + 1;

            int pull2 = ownedVerticalLines[next]->getUsedLineBinder()->getPull();
            int negspace2;
            if(pull < 0)
                negspace2 = ownedVerticalLines[next]->getUsedLineBinder()->getSeekFreeSpaceNegative();
            else
                negspace2 = ownedVerticalLines[next]->getUsedLineBinder()->getSeekFreeSpacePositive();
            if(pull == 0)
                continue;
            if(pull < 0)
            {
                int val2 = std::max(pull2,negspace2);
                int val1 = std::max(pull,negspace);
                if(dynamic_cast<CFGLayer*>(this))
                {
                    std::swap(val1,val2);
                }
                int diff = (val1 - val2);

                if(diff == 0)
                {
                    if(ownedVerticalLines[j]->getLineSize() > ownedVerticalLines[next]->getLineSize())
                    {
                    	donesomething |= LineBinder::swapLineHolder(ownedVerticalLines[j]->getUsedLineBinder(),ownedVerticalLines[next]->getUsedLineBinder());
                    }
                }
                if(diff > 0) //bigger absolute bug in nr 3
                {
                	donesomething |= LineBinder::swapLineHolder(ownedVerticalLines[j]->getUsedLineBinder(),ownedVerticalLines[next]->getUsedLineBinder());
                }
            }
            else
            {
                int val2 = std::min(pull2,negspace2);
                int val1 = std::min(pull,negspace);
                if(dynamic_cast<CFGLayer*>(this))
                {
                    std::swap(val1,val2);
                }
                int diff = (val1 - val2);

                if(diff == 0)
                {
                    if(ownedVerticalLines[j]->getLineSize() > ownedVerticalLines[next]->getLineSize())
                    {
                    	donesomething |= LineBinder::swapLineHolder(ownedVerticalLines[j]->getUsedLineBinder(),ownedVerticalLines[next]->getUsedLineBinder());
                    }
                }

                if(diff > 0) //bigger absolute
                {
                	donesomething |= LineBinder::swapLineHolder(ownedVerticalLines[j]->getUsedLineBinder(),ownedVerticalLines[next]->getUsedLineBinder());
                }

            }
        }
        if (!donesomething)
        	break;
    }
}

bool VerticalLineOwner::isInside(LineBinder* binder)
{
    auto lines = binder->getLines();
    for(VerticalLine* line : *lines)
    {
        if(std::find(ownedVerticalLines.begin(),ownedVerticalLines.end(),line) != ownedVerticalLines.end())
            return true;
    }
    return false;
}

void VerticalLineOwner::swapLine(LineBinder* binder,VerticalLine* inLine)
{
    auto lines = binder->getLines();
    for(auto line = lines->begin();line != lines->end();++line)
    {
        auto found = std::find(ownedVerticalLines.begin(),ownedVerticalLines.end(),*line);
        if(found != ownedVerticalLines.end())
        {
            auto otherItter = std::find(ownedVerticalLines.begin(),ownedVerticalLines.end(),inLine);
            std::iter_swap(found,otherItter);
            std::swap((*found)->x,(*otherItter)->x);
            return;
        }
    }
    return; //should never happen
}

LineBinder* VerticalLineOwner::getInnerLineHolder(LineBinder* a,LineBinder* b)
{
    for(auto line = ownedVerticalLines.begin();line != ownedVerticalLines.end();++line)
    {
        if((*line)->getUsedLineBinder() == a || (*line)->getUsedLineBinder() == b)
        {
            ++line;
            if((*line)->getUsedLineBinder() == a || (*line)->getUsedLineBinder() == b)
                return nullptr;
            else
                return (*line)->getUsedLineBinder();
        }
    }
    return nullptr; //should not happen

}

void VerticalLineOwner::PullVerticalLines()
{
    for(auto line:ownedVerticalLines)
    {

        int pull = line->getUsedLineBinder()->getPull();
        int negspace;
        int val;
        if(pull < 0)
        {
            negspace = line->getUsedLineBinder()->getSeekFreeSpaceNegative();
            val = std::max(pull,negspace);
        }
        else
        {
            negspace = line->getUsedLineBinder()->getSeekFreeSpacePositive();
            val = std::min(pull,negspace);
        }
        if(!line->getUsedLineBinder()->canSeek(val))
            continue;
        line->getUsedLineBinder()->seek(val);
    }
}
void VerticalLineOwner::DebugPrintOwnedVLines()
{
	for (auto i : ownedVerticalLines)
	{
		printf("line(id: %i (%i (Lay %i) -> %i (Lay %i))) x %i",i->edge->getID(),
				i->edge->getSrc()->getID(),i->edge->getSrc()->getDepth(),
				i->edge->getDest()->getID(),i->edge->getDest()->getDepth(),
				i->x);
		printf("\r\n");
		fflush(stdout);
	}
}
