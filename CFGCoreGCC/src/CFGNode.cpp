/*
 * Copyright 2014-2022 joerg All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "CFGNode.h"

#include "CFGEdge.h"

#include "CFGLayer.h"

#include "cfgrange.h"

#include <random>

#include <unordered_set>

#include "settings.h"


#include <limits>

#include <assert.h>

#include <algorithm>

static bool inrange(int val,int range)
{
    if(-range < val && val < range)
        return true;
    else
        return false;
}

CFGNode::CFGNode(int Width, int Height, int Id)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B49 begin
{
    id = Id;
    height = Height;
    width = Width;
    widthBox = Width;

}
CFGNode::~CFGNode()
{

}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B49 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFGNode::setLayer(CFGLayer &layer)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B5A begin
{
    this->layer = &layer;
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B5A end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

int CFGNode::getCenterx() const
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B5F begin
{
    return x + width/2;
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B5F end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFGNode::setCenterx(int x)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B63 begin
{
    this->x = x - width/2;
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B63 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFGNode::setCenterxAuto()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B66 begin
{
    //calculate the average across all in going edges that go downwards
    int average = 0;
    int num = 0;
	for(auto edge : inEdge)
    {
        if(edge->isDown())
        {
            average += edge->getSrc()->getCenterx();
            num++;
        }
    }
    if(num != 0)
    {
        setCenterx(average/num);
    }
    else
    {
        setCenterx(0); //fallback if this is the first
    }
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B66 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFGNode::seekPosition(int x)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B68 begin
{
    this->x += x;

    CFGNode* current = this;

    //propagate seek down
    while(true)
    {
        current = current->getNextNodeInLine();
        if(current)
        {
            current->x += x;
        }
        else
        {
            break;
        }
    }

    //propagate seek up
    current = this;
    while(true)
    {
        current = current->getPrefNodeInLine();
        if(current)
        {
            current->x += x;
        }
        else
        {
            break;
        }
    }
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B68 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFGNode::hasplaced(CFGNode &Child)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B6E begin
{
    placed.push_back(&Child);
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B6E end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFGNode::gotPlaced(CFGNode& Mother)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B70 begin
{
    mother = &Mother;
}

void CFGNode::resortIOx()
{
    std::sort(
                inEdge.begin(),
                inEdge.end(),
                [](CFGEdge* a ,CFGEdge* b){

                    int x1,x2;
                    if(a->isDown())
                        x1 = (*(++a->getVerticalLines()->rbegin()))->getx();
                    else
                        x1 = (*(++a->getVerticalLines()->begin()))->getx();
                    if(b->isDown())
                        x2 = (*(++b->getVerticalLines()->rbegin()))->getx();
                    else
                        x2 = (*(++b->getVerticalLines()->begin()))->getx();
                    return x1 < x2;
                });

    std::sort(
                outEdge.begin(),
                outEdge.end(),
                [](CFGEdge* a ,CFGEdge* b){

                    int x1,x2;
                    if(a->isDown())
                        x1 = (*(++a->getVerticalLines()->begin()))->getx();
                    else
                        x1 = (*(++a->getVerticalLines()->rbegin()))->getx();
                    if(b->isDown())
                        x2 = (*(++b->getVerticalLines()->begin()))->getx();
                    else
                        x2 = (*(++b->getVerticalLines()->rbegin()))->getx();
                    return x1 < x2;
                });

    fixIOx();
}

bool CFGNode::tryFixIx(int maxSkips)
{
	int edgeCount = inEdge.size() + maxSkips;
	int linex;
	if(edgeCount & 1)
		linex = x + widthBox/2 - (edgeCount+1) * IOhorizontalLineOffset/2;
	else
		linex = x + widthBox/2 - edgeCount * IOhorizontalLineOffset/2 - IOhorizontalLineOffset/2;
	for(auto edge : inEdge)
    {
        linex += IOhorizontalLineOffset;
        bool redo;
		do
		{
			redo = false;
			//prevent overlaying of incoming with outgoing from above
			if(auto prev = this->layer->getPrev())
			{
				for(auto i : *(prev->getNodes()))
				{
					for (auto j : *(i->getOutEdges()))
					{
						VerticalLine* toCheck;
				        if(j->isDown())
				        	toCheck = j->getVerticalLines()->begin()->get();
				        else
				        	toCheck = j->getVerticalLines()->rbegin()->get();

        	    		if (inrange(toCheck->getx() - linex,vertikalLineMinOffset))
        	    		{
        	    			linex += IOhorizontalLineOffset;
        	    			redo = true;
        	    			if(--maxSkips < 0)
        	    				return true;
        	    		}
					}
				}
			}
		}
		while(redo);
		VerticalLine* tofix;
        if(edge->isDown())
            tofix = edge->getVerticalLines()->rbegin()->get();
        else
            tofix = edge->getVerticalLines()->begin()->get();
        tofix->setx(linex);
    }
	return false;
}

void CFGNode::fixIOx()
{
	int maxSkips = 0;
	while(tryFixIx(maxSkips++))
		;

	int edgeCount = outEdge.size();
	int linex;
	if(edgeCount & 1)
		linex = x + widthBox/2 - (edgeCount+1) * IOhorizontalLineOffset/2;
	else
		linex = x + widthBox/2 - edgeCount * IOhorizontalLineOffset/2 - IOhorizontalLineOffset/2;
	for(auto edge : outEdge)
    {
		VerticalLine* tofix;
        linex += IOhorizontalLineOffset;
        if(edge->isDown())
            tofix = edge->getVerticalLines()->begin()->get(); //swapped to upper
        else
            tofix = edge->getVerticalLines()->rbegin()->get();
        tofix->setx(linex);
    }
}

// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B70 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

int CFGNode::getBoxCenterx()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B8A begin
{
    return x + widthBox/2;
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000B8A end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

bool CFGNode::verticalCanSeek(int xOffset, VerticalLine &line)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C1C begin
{
    //don't change the order
    if(line.smoothOffset + xOffset < 0)
    {
        return false;
    }
    if(&line == *ownedVerticalLines.rbegin())
    {
        auto node = layer->getRightOfx(x);
        if(!node)
            return true;
        if(line.getx() + xOffset > node->getx()) //compare to the Node right to this one
            return false;
        else
            return true;
    }
    else
    {

        //get the next in line
        auto nextitter = ownedVerticalLines.begin();
        while(*nextitter != &line)
            ++nextitter;
        ++nextitter;

        int offsetNededForNext =-((*nextitter)->smoothOffset - xOffset);

        if(offsetNededForNext > 0)
            return  (*nextitter)->canSeek(offsetNededForNext);
        else
            return true;
    }
}

bool CFGNode::selfCheck()
{
    for(VerticalLine* line : ownedVerticalLines)
    {
        if(line->smoothOffset < 0)
            return false;
    }
    return true;
}

// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C1C end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFGNode::verticalSeek(int xOffset, VerticalLine& line)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C2C begin
{
    if(&line == *ownedVerticalLines.rbegin())
    {
        line.smoothOffset += xOffset;
        line.setx(line.getx() + xOffset);
        if(line.smoothOffset < 0)
        {
            //get the prev in line
            auto nextitter = ownedVerticalLines.begin();
            while(*nextitter != &line)
                ++nextitter;
            --nextitter;

            (*nextitter)->seek(line.smoothOffset);
            assert(selfCheck());
        }
        return;
    }
    //get the next in line
    auto nextitter = ownedVerticalLines.begin();
    while(*nextitter != &line)
        ++nextitter;
    ++nextitter;

    //correct the vals for this and the next (next must be fixed)
    line.smoothOffset += xOffset;
    line.setx(line.getx() + xOffset);
    //this dose not change x!!!
    (*nextitter)->smoothOffset -= xOffset;

    //fix the next
    int offsetNededForNext = -(*nextitter)->smoothOffset;
    if(offsetNededForNext > 0)
    {
         (*nextitter)->seek(offsetNededForNext);
    }
    if(line.smoothOffset < 0)
    {
        --nextitter;
        if(nextitter == ownedVerticalLines.begin())
        {
            line.seek(-line.smoothOffset);
            return;
        }
        --nextitter;
        (*nextitter)->seek(line.smoothOffset);
    }
    //assert(selfCheck());
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C2C end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFGNode::attachVerticalLine(VerticalLine &line, int hintx)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BB5 begin
{
    ownedVerticalLines.push_back(&line);
    CFGRange r;
    CFGNode * rightof = layer->getRightOfx(hintx);
    if(rightof)
        r.setRange(x + width,layer->getRightOfx(hintx)->getx());
    else
        r.setRange(x + width,std::numeric_limits<int>::max());

    line.setx(r.getNear(hintx));
    line.setOwner(*this);
    width += horizontalLineOffset;
}
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BB5 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

int CFGNode::getx() const
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BBB begin
{
    return x;
}
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BBB end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

unsigned int CFGNode::getWidth() const
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BBE begin
{
    return width;
}
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BBE end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

unsigned int CFGNode::getWidthBox() const
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BC0 begin
{
    return widthBox;
}
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BC0 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFGNode::setWidthBox(int x)
{
    widthBox = x;
    width = x;
}

int CFGNode::getDepth() const
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BC2 begin
{
    return depth;
}
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BC2 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFGNode::setDepth(int depth)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BC7 begin
{
    this->depth = depth;
}
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BC7 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BD0 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFGNode::addOutEdge(CFGEdge &edge)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BD5 begin
{
    outEdge.push_back(&edge);
}
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BD5 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFGNode::addInEdge(CFGEdge& edge)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BD8 begin
{
    inEdge.push_back(&edge);
}
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BD8 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

std::vector<CFGEdge *> *CFGNode::getOutEdges()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BDB begin
{
    return &outEdge;
}
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BDB end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

std::vector<CFGEdge *> *CFGNode::getInEdges()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BDD begin
{
    return &inEdge;
}
// section -64--88--78-20-55cbe988:15071e72dc6:-8000:0000000000000BDD end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

int CFGNode::gety() const
{
    return y;
}
void CFGNode::sety(int y)
{
    this->y = y;
}

unsigned int CFGNode::getHeight() const
{
    return height;
}
int CFGNode::getID() const
{
    return id;
}
void CFGNode::fixAttachedx()
{
    int currentx = x + widthBox;
	for(auto Vline : ownedVerticalLines)
    {
        currentx += IOhorizontalLineOffset;
        //currentx += Vline->smoothOffset;  //only makes stuff slower
        Vline->setx(currentx);
    }
}

CFGNode* CFGNode::getPrefNodeInLine()
{
    CFGNode * ret = nullptr;
    bool foundMore = false; //only one per search else non
	for(auto edge : inEdge)
    {
        if(edge->getSrc()->getDepth() == edge->getDest()->getDepth() + 1) //is placing edge
        {
            auto src = edge->getSrc();
            int number = 0;
            for(auto outedge : (*src->getOutEdges())) //the src is only allowed to have one placing out edge
            {
                if(outedge->getSrc()->getDepth() == edge->getDest()->getDepth() + 1)
                    number++;
            }
            if(number == 1)
            {
                if(ret)
                    foundMore = true;
                else
                    ret = src;
            }
        }
    }
    if(foundMore)
        return nullptr;
    return ret;
}

CFGNode* CFGNode::getNextNodeInLine()
{
    CFGNode * ret = nullptr;
    bool foundMore = false; //only one per search else non
	for(auto edge : outEdge)
    {
        if(edge->getSrc()->getDepth() + 1 == edge->getDest()->getDepth()) //is placing edge
        {
            auto dest = edge->getDest();
            int number = 0;
            for(auto inedge : (*dest->getInEdges())) //the src is only allowed to have one placing out edge
            {
                if(inedge->getSrc()->getDepth() + 1 == inedge->getDest()->getDepth())
                    number++;
            }
            if(number == 1)
            {
                if(ret)
                    foundMore = true;
                ret = dest;
            }
        }
    }
    if(foundMore)
        return nullptr;
    return ret;
}
int CFGNode::getSeekFreeSpacePositive(VerticalLine& line)
{
    auto node = layer->getRightOfx(x);
    if(!node)
        return std::numeric_limits<int>::max();
    int ret = node->getx() - getWidthBox() - getx();
    ret -= (ownedVerticalLines.size() + 1) * horizontalLineOffset;
    for(unsigned int i = 0; i < ownedVerticalLines.size();++i)
    {
        ret += ownedVerticalLines[i]->smoothOffset;
        if(ownedVerticalLines[i] == &line)
            return ret;
    }
    //this should never happen
    return ret;
}
