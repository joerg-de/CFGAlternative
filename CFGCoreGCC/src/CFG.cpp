/*
 * Copyright 2014-2022 joerg All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "CFG.h"
#include "CFGLayer.h"

#include <deque>
#include <unordered_set>

#include <chrono>

#include <algorithm>

#include "settings.h"

bool sortVerticalLines(VerticalLine* first,VerticalLine* secound)
{
    int size1 = first->getPrev()->getLineSize();
    int size2 = secound->getPrev()->getLineSize();
    if(size1 != size2)
        return size1 > size2;
    else
        return first->getEdgeID() < secound->getEdgeID();
}
void CFG::solve(CFGNode &entry)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:000000000000086B begin
{

    STARTTIMEANA(0);

    //fix the size
    for(auto node : nodes)
    {
        if(node->getWidthBox() < IOhorizontalLineOffset*node->getInEdges()->size())
        {
            node->setWidthBox(IOhorizontalLineOffset*node->getInEdges()->size());
        }
        if(node->getWidthBox() < IOhorizontalLineOffset*node->getOutEdges()->size())
        {
            node->setWidthBox(IOhorizontalLineOffset*node->getOutEdges()->size());
        }
    }
    srand(0); //make sure the graph looks the same every time

    setLayer(entry); //assignes the layer to the Layer

    //this calculates the current x values for the Nodes
    for(auto& lay : layers)
    {
        for(auto node : (*lay->getNodes()))
        {
            node->setCenterxAuto(); //places new Nodes
        }
        fixNodex(*lay); //impr. x vals based on the new CFGNodes
    }

    //this palces and generates the lines
    runAllNodesPlacedInLayerUpdate();
    mapLines();


    //this makes sure that the IO have good IO x vals
    for(auto& currentLayer : layers)
    {
        for(auto node : (*currentLayer->getNodes()))
        {
            node->fixIOx();
        }
    }

    reduceKinks();

    //make sure the IO are OK
    for(auto node : nodes)
    {
        node->resortIOx();
    }

    //fix up the y values
    layers[0]->sety(0);

    for(auto& l : layers)
    {
        l->sortHorizontalLines();
    }
    updateyPos();


    TAKETIMEANA(0,"solve");
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:000000000000086B end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFG::addEdge(CFGEdge &edge)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000893 begin
{
    edges.push_back(&edge);
    search.addlink(edge.getSrc()->getID(),edge.getDest()->getID());
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000893 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFG::addNode(CFGNode &node)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000896 begin
{
    nodes.push_back(&node);
    search.addID(node.getID());
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000896 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFG::shortenUpEdges()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C4A begin
{
    throw 1; //todo
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C4A end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFG::runAllNodesPlacedInLayerUpdate()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:00000000000008A3 begin
{
    for(auto& edge : edges)
    {
        edge->generateLines(layers);
    }
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:00000000000008A3 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFG::updateyPos()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C34 begin
{
    for(auto& l : layers)
    {
        l->updateySize();
    }
    for(auto& l : layers)
    {
        l->updateyIO();
    }
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C34 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFG::setLayer(CFGNode &entry)
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C36 begin
{
    std::vector<bool> placedNodesFild(nodes.size(),false);
    std::vector<bool> checkedNodesFild(nodes.size(),false);
    entry.setDepth(0); //the entry is normally the one at the top
    step1(entry,placedNodesFild,checkedNodesFild);

    //check if we missed something and do a dirty fix than continue with Step1 based on that fix
    bool donesomething;
    do
    {
        CFGNode * foundsrc = NULL;
        CFGNode * foundtar = NULL;

        donesomething = false;
        unsigned int minunk = 0xFFFFFFFF;
        int maxdepth = -0x7FFFFFFF;
        for (auto node : nodes)   //backfall if step1 does not work (obfuscation etc...)
        {
            if (placedNodesFild[node->getID()])
            {
                for(auto l1 : *node->getOutEdges())
                {
                    auto t1 = l1->getDest();
                    if (!placedNodesFild[t1->getID()])
                    {
                        //get the number of unknown src
                        unsigned int nuber = 0;
                        for(auto l2 : *node->getInEdges())
                        {
                            auto t1 = l2->getSrc();
                            if (!placedNodesFild[t1->getID()])
                            {
                                nuber++;
                            }
                        }

                        if(!(nuber ==  minunk) || maxdepth < t1->getDepth())
                        {
                            foundsrc = node;
                            foundtar = t1;
                            minunk = nuber;
                            maxdepth = t1->getDepth();
                        }
                    }
                }
            }
        }
        if(foundsrc)
        {


            foundsrc->hasplaced(*foundtar);

            foundtar->setDepth(foundsrc->getDepth()  + 1);
            placedNodesFild[foundtar->getID()] = true;

            step1(*foundtar,placedNodesFild,checkedNodesFild);
            donesomething = true;
        }
    }
    while (donesomething);

    //get the max depth
    int maxlayer = 0;
    int minlayer = 0;
    for(auto node : nodes)
    {
        if(maxlayer < node->getDepth())
            maxlayer = node->getDepth();
        if(minlayer > node->getDepth())
            minlayer = node->getDepth();
    }
    //generate the layer
    minlayer -= 1; //we need on for the Vertical lines that go into a layer 0
    CFGLayer *last = nullptr;
    for(auto i = minlayer; i<= maxlayer;i++)
    {
        auto lay = std::make_unique<CFGLayer>(last);
        last = &*lay;
        layers.push_back(std::move(lay));
    }
    //assigne Nodes
    for(auto node : nodes)
    {
        node->setDepth(node->getDepth() - minlayer); //normalize so layer 0 is Depth 0
        layers[node->getDepth()]->addNode(*node);
    }
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C36 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFG::fixNodex()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C38 begin
{
    //run internUpdateNodex untill all x values are fixed or timeout (should not happen)
    int rounds = 0;
    bool donesomething;
    do
    {
       rounds++;
       donesomething = false;
       for(auto i = layers.rbegin(); i != layers.rend();i++)
       {
           if((*i)->internUpdateNodex())
               donesomething = true;
       }
    }
    while(donesomething && rounds < 100);
}
void CFG::fixNodex(CFGLayer &hint)
{
    hint.internUpdateNodex();
    fixNodex();
}

// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C38 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFG::mapLines()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C3A begin
{
    for(auto node : (*layers[0]->getNodes())) //is needed to calc the currect Node
    {
        node->fixIOx();
    }
    for(auto& currentLayer : layers)
    {
        CFGLayer * lay = currentLayer->getNext();
        if(lay)
        {
            for(auto node : (*lay->getNodes())) //is needed to calc the currect Node
            {
                node->fixIOx();
            }
        }
        currentLayer->routeLines(); //this attaches the lines to the nodes
        fixNodex(*currentLayer); //to make sure if a line starts the correct Node is selected

    }
    //make sure we return with valid data
    for(auto& currentLayer : layers)
    {
        for(auto node : (*currentLayer->getNodes()))
        {
            node->fixIOx();
            node->fixAttachedx();
        }
        currentLayer->fixAttachedx();
    }
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C3A end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFG::reduceKinks()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C40 begin
{

    //sort lines before kink reducing
    for(auto node : nodes)
    {
        node->startResort();
        std::sort(
                    node->getVericalLinesForResort()->rbegin(),
                    node->getVericalLinesForResort()->rend(),
                    sortVerticalLines
                    );
        node->endResort();
        node->fixAttachedx();
    }

    for(auto &layer : layers)
    {
        layer->startResort();
        std::sort(
                    layer->getVericalLinesForResort()->rbegin(),
                    layer->getVericalLinesForResort()->rend(),
                    sortVerticalLines
                    );
        layer->endResort();
        layer->fixAttachedx();
    }

    for(auto node : nodes)
    {
        node->resortIOx();
    }

    bool donesomething;
    do
    {
        donesomething = false;
        for(auto layer = layers.begin();layer != layers.end();layer++)
        {
            for(auto node : *layer->get()->getNodes())
            {
                for(auto line : *node->getVericalLinesForResort())
                {
                    VerticalLine* next = line->getNext();
                    if(next)
                        if(line->glue(*next))
                            donesomething = true;
                }
            }
            for(auto line : *layer->get()->getVericalLinesForResort())
            {
                VerticalLine* next = line->getNext();
                if(next)
                    if(line->glue(*next))
                        donesomething = true;
            }
        }
    }
    while(donesomething);


    /*
    for(auto layer = layers.begin();layer != layers.end();layer++)
    {
        for(auto node : *layer->get()->getNodes())
        {
            for(auto edge : *node->getOutEdges())
            {
                auto line = edge->getVerticalLines()->begin()->get();
                VerticalLine* next = line->getNext();
                if(next)
                    line->glue(*next);
            }
            for(auto edge : *node->getInEdges())
            {
                auto line = edge->getVerticalLines()->begin()->get();
                VerticalLine* next = line->getNext();
                if(next)
                    line->glue(*next);
            }
        }
    }*/
    for(auto node : nodes)
    {
        node->internResort();
    }
    for(auto node : nodes)
    {
        node->PullVerticalLines();
    }

    for(auto &layer : layers)
    {
        layer->internResort();
    }
    for(auto &layer : layers)
    {
        layer->PullVerticalLines();
    }

}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C40 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element

void CFG::cleanup()
// don't delete the following line as it's needed to preserve source code of this autogenerated element
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C48 begin
{
}
// section -64--88--78-20-3797976a:1506cf30996:-8000:0000000000000C48 end
// don't delete the previous line as it's needed to preserve source code of this autogenerated element


std::vector<CFGNode *> *CFG::getNodes()
{
    return &nodes;
}
std::vector<CFGEdge *> *CFG::getEdges()
{
    return &edges;
}
std::vector<std::unique_ptr<CFGLayer> > *CFG::getLayers()
{
    return &layers;
}

//this claculates the depth of the CFGNode (only parts where the function is sure where to place all others are not placed !!!)
void CFG::step1(CFGNode &entry, std::vector<bool> &placedNodesFild, std::vector<bool> &checkedNodesFild)
{
    //init the first
    placedNodesFild[entry.getID()] = true;
    std::deque<CFGNode*> mystack;
    mystack.push_back(&entry);

    //get new till the stack is empty
    while (!mystack.empty())
    {
        CFGNode* current = *mystack.begin();
        mystack.pop_front();
        checkedNodesFild[current->getID()] = true;
        //place all the matching
        for(CFGEdge* l1 : *current->getOutEdges())
        {
        	//this is default
        	CFGNode* bestNode = current;
            auto dest_node = l1->getDest();
            //TODO the last one possible should place this (bestNode) --> that excludes all that are donated by the block itself + all that go trough an obj that is already placed
            bool skip = false;
            int size = dest_node->getInEdges()->size();
            if(size != 1)
            {
                //disable all connections to the destination node we know
                for(CFGEdge* l2 : *dest_node->getInEdges())
                {
                    auto src = l2->getSrc();
                    if(checkedNodesFild[src->getID()])
                    {
                        search.removelink(src->getID(),dest_node->getID());
                    }
                }
                if (search.isconnected(entry.getID(),dest_node->getID()) == 0) //there is still a indirect connection
                {
					for(CFGEdge* l2 : *dest_node->getInEdges())
					{
						auto src = l2->getSrc();
						//check if the last possible connection
						search.addlink(src->getID(),dest_node->getID());
						if(!checkedNodesFild[src->getID()])
						{
							int res = search.isconnected(entry.getID(),dest_node->getID());
							if(res != 0)
							{
								skip = true;
								break;
							}
						}
						search.removelink(src->getID(),dest_node->getID());
					}
                }
                else
                {
                	skip = true;
                }

                //enable all connections we know
                for(CFGEdge* l2 : *dest_node->getInEdges())
                {
                    auto src = l2->getSrc();
                    //check if the last possible
                    if(checkedNodesFild[src->getID()])
                    {
                        search.addlink(src->getID(),dest_node->getID());
                    }
                }
            }
            if(skip)
                continue;


            //process (only happens once)
            if(!placedNodesFild[dest_node->getID()])
            {
            	bestNode->hasplaced(*dest_node);

                dest_node->setDepth(bestNode->getDepth() + 1);
                placedNodesFild[dest_node->getID()] = true;
                mystack.push_back(dest_node);
            }
        }
    }
}
